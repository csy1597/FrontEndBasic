# Variable(변수)

    ### 변수란

        - 변수는 데이터를 저장할 수 있는 메모리 공간이다.
        - 변수에는 오직 하나의 데이터만 저장할 수 있다.

    ### var, let, const 차이점

        1. var
            - 변수 선언 방식에 있어 큰 단점을 가지고 있다.
            - 변수를 여러번 선언해도 에러가 발생하지 않고 각각 다른 값을 출력한다.
            - 변수를 선언하고 간단한 테스트에는 편리할 수 있으나 코드량이 많아지면 
              어디에서 어떻게 사용 되는지도 파악하기 힘들고 값이 바뀔 우려가 있다.
        
        -> 그래서 ES6 이후, 이를 보완하기 위해서 '변수선언' 방식이 let, const 가 추가 되었다.

        2. let
            - 변수 재선언 불가능, 재할당 가능
            - 같은 변수명을 사용할 수 없으나, 값은 바꿀수 있다.
            - 한번 선언한 값을 바꿀 목적으로 사용한다.
            - 실무에서는 잘 사용하지 않는다.
        
        3. const
            - 변수 재선언, 재할당 불가능
            - 같은 변수명을 사용하거나, 값을 변경할 수 없다.
            - 한번 선언하면 바꾸지 않을 목적으로 사용한다.

# Hoisting(호이스팅)이란 

    - 자바스크립트는 절차지향형 언어이다. 순차적으로 읽어 내려간다.
      밑에서 함수, 변술,ㄹ 선언한 것을 호이스팅으로 적용해서 읽어 내려가도록 해준다.
    - var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 
      특성을 말한다.
    - 자바스크립트는 ES6에서 도입된 let, const 를 포함하여 *모든선언을 호이스팅한다.
        *(var, let, const, function, function*, class)
    - var 로 선언된 변수와는 달리 let 으로 선언된 변수를 선언문 이전에 참조하면 
      에러(ReferenceError)가 발생한다.
    - let 으로 선언된 변수는 스코프의 시작에서 변수의 선언까지 *일시적사각지대에 빠지기 때문이다.
      *일시적사각지대(Temporal Dead Zone:TDZ)
    - var 로 선언된 변수는 선언 단꼐와 초기화 단계가 한번에 이루어 지지만, 
      let 으로 선언된 변수는 선언 단계화 초기화 단계가 분리되어 진행된다.

# import, export, export default 의 차이  

    ### import
        
        - 무언갈 가져오고 싶을 때 사용한다.
        - 한꺼번에 모든걸 가져오는 방식을 사용하면 코드는 짧아지지만,
          가져올 대상을 구체적으로 명시하는게 좋다.
    
    ### export 

        - 함수 또는 변수-> 모듈이라는 개념으로 다른 용도로 가져다 쓰는 개념
        
        - 여러개를 보내기 위해서 하나이상의 복수개념의 모듈을 보내기 위해서 사용한다,
        - javascript 모듈에서 함수, 객체, 원시값을 내보낼 때 사용한다.
          ES6 에서 선언한 내용을 다른 곳에서 import 하기 위해 사용한다.
        - import 할 때는, 무저간 export 한 객체/함수 이름을 사용한다.
        - 해당 변수만 export 하고 import 시에 중괄호로 사용한 이름을 감싸서 그대로 가져와야 한다.

        장점과 단점 -> 내보냈을 때 사용한 이름 그대로 가져오므로 관련 정보를 파악하기 쉽다.
    
    ### exports

        - 모듈에서 함수, 객체, *원시값을 객체의 형태로 내보낼 때 사용한다.
            * 원시값(primitive): 객체가 아니면서 메소드도 가지지 않는 데이터
              (string, number, bigint, boolean, undefined, symbol)
        - 겉보기엔 원시값처럼 보이는 null도 있지만,
          사실 모든 Object, 모든 구조화된 자료형은 프로토타입 체인에 따라 null 자손이다.
    
    ### expoer default

        - 개발자가 원하는 이름으로 import 할 수 있다.
        - 분리되어 있는 파일 내, 내볼낼 하나의 고정된 값만 내볼낼때 사용하고 
          export default 는 내보낸 값만 가져올 수 있다.

        * 장점 -> named export 와 다르게 default export 는 가져오기 할 때 
                  개발자가 원하는 대로 이름을 지정해 줄 수 있다.
        
        * 단점 -> import 하는 것이 정확히 어떤 건지 알 수 없다.
          보완점 -> named export 만 사용한다.
                    default export 한 것을 가져올 때 아래와 같이 파일이름과 동일한 이름을 
                    사용하도록 팀원들끼리 내부 규칙을 정할 수 있다.

    ### require 

        - module 객체에 담아 가져온다.(import 는 갑사 자체를 가져온다.)

# 비동기(Asynchronous)란     

    1. 먼저 동기식 작업부터 확인한다.
       먼저 시작된 하나의 작업이 끝날 때까지 다른 작업을 시작하지 않고 기다렸다가 
       다 끝나면 새로운 작업을 시작하는 방식이다.
       작업이 직렬로 배치되어 실행되며 작업 실행의 순서가 확실히 정해져 있는 것을 '동기식 처리'라 부른다.
    
       비동기식은 동기식 방식솨는 다르게 먼저 시작된 작업의 완료 여부와 상관없이 새로운 작업을
       시작하는 방식이다. 작업이 병렬로 배치되어 실해되며 작업의 순서가 확실하지 않아 나중에
       시작된 작업이 먼저 끝나는 경우도 발생한다. 이와 같은 방식을 '비동기식 처리'라고 부른다

    2. 비동기식의 callback / promise / async / await

        - 주로 백엔드와 통신을 하기 위한 기술로써 데이터를 요청하고 응답받는데 내부적으로 처리하는데 
          순서와 상관없이 상요하는 기술로써 먼저 호출을 하더라도 순서가 보장되지 않는다.
        - 화면 전환이 이루어지지 않고 이루어지기 때문에 현대 서비스에 맡는 기술

        1) callback 함수
            - callback 함수는 남용하게 되면 가독성과 에러처리 등에서 불편함이 발생된다.
              이를 해결하기 위해 ES6 에서 비동기 처리의 새로운 방법으로 promisr 객체가 등장한다.
        
        2) promise 객체
            - 비동기 통신에 적용하는 기수린데 순서가 보장되지 않는 비동기 통신에 순서를 지키고자 적용하는 개념이다.
            - 비동기 작업의 최종완료(또는 실패) 와 그 결과 값을 나타낸다.
            - 자바스크립트 비동기 처리에 사용되는 객체이다. 이를 사용하면 비동기 작업이 종료된 이후에
              성공 결과 값이나 실패에 대해 처리할 수 있다.
            - promise 는 다음 중 하나의 상태를 가진다.
                *대기(panding): 이행하거나 거부되지 않은 초기상태
                *이행(fulfilled): 연산이 성공적으로 완료됨
                *거부(rejected): 연산이 실패함
            - new Promise() 객체를 사용하여 callback 함수를 선언할 수 있다.
              이 때의 인자는 resolve, reject 를 사용한다.
              resolve 는 결과가 성공인 promise 객체를 반환
              reject 는 결과가 실패인 promise 객체를 반환
              반환된 promise 객체를 처리할 때 성공시 then 을 사용하고 실패시 catch를 사용하여 처리한다.

            *정리: Promise 객체 
                - 성공: resolve / then
                - 실패: reject / catch

              - Promise 방식이 callback 함수보다 좋은점: then 을 연결하여 코드가 간단해진다.

        3) Promise 를 활용한 async / await
            - ES2017 에 새로 추가된 async / await 는 Promise 객체를 기반으로 사용한다.
            - resolve, reject, then, catch 를 사용하지 않는다.

        4) async 
            - 기본 메소드 앞에 async 만 붙이면 반환값은 promise 객체가 된다.

        5) await
            - await 가 붙으면 반환된 Promise 객체에서 실제 메소드의 반환값을 가져오게 된다.

        6) 결과 처리 방법
            - 기존에 then 과 catch 로 성공과 실패를 확인 했다면 async / await 에소는 
              try-catch  로 확인하게 된다.
              성공일 때는 try 부분이 실행되고 실패일 경우는 catch 부분이 실행된다.

# 함수선언 방법
     
